package cn

//ç¿»è½¬ä¸€æ£µäºŒå‰æ ‘ã€‚
//
// ç¤ºä¾‹ï¼š 
//
// è¾“å…¥ï¼š 
//
//      4
//   /   \
//  2     7
// / \   / \
//1   3 6   9 
//
// è¾“å‡ºï¼š 
//
//      4
//   /   \
//  7     2
// / \   / \
//9   6 3   1 
//
// å¤‡æ³¨: 
//è¿™ä¸ªé—®é¢˜æ˜¯å—åˆ° Max Howell çš„ åŽŸé—®é¢˜ å¯å‘çš„ ï¼š 
//
// è°·æ­Œï¼šæˆ‘ä»¬90ï¼…çš„å·¥ç¨‹å¸ˆä½¿ç”¨æ‚¨ç¼–å†™çš„è½¯ä»¶(Homebrew)ï¼Œä½†æ˜¯æ‚¨å´æ— æ³•åœ¨é¢è¯•æ—¶åœ¨ç™½æ¿ä¸Šå†™å‡ºç¿»è½¬äºŒå‰æ ‘è¿™é“é¢˜ï¼Œè¿™å¤ªç³Ÿç³•äº†ã€‚ 
// Related Topics æ ‘ 
// ðŸ‘ 798 ðŸ‘Ž 0

//leetcode submit region begin(Prohibit modification and deletion)
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func invertTree(root *TreeNode) *TreeNode {
	var stack []*TreeNode
	curr := root

	for curr != nil || len(stack) > 0 {
		if curr == nil {
			curr = stack[len(stack)-1]
			stack = stack[:len(stack)-1]
		}

		curr.Left, curr.Right = curr.Right, curr.Left

		if curr.Right != nil {
			stack = append(stack, curr.Right)
		}

		curr = curr.Left
	}

	return root
}

//leetcode submit region end(Prohibit modification and deletion)

func invertTreeRecursive(root *TreeNode) *TreeNode {
	if root == nil || (root.Left == nil && root.Right == nil) {
		return root
	}

	root.Left, root.Right = root.Right, root.Left

	invertTree(root.Left)
	invertTree(root.Right)

	return root
}
